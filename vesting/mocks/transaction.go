// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/hyperledger/fabric-chaincode-go/pkg/cid"
	"github.com/hyperledger/fabric-protos-go/peer"
	"github.com/p2eengineering/kalp-sdk-public/kalpsdk"
	"github.com/p2eengineering/kalp-sdk-public/response"
	"google.golang.org/protobuf/types/known/timestamppb"
)

type TransactionContext struct {
	CreateCompositeKeyStub        func(string, []string) (string, error)
	createCompositeKeyMutex       sync.RWMutex
	createCompositeKeyArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	createCompositeKeyReturns struct {
		result1 string
		result2 error
	}
	createCompositeKeyReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DelStateWithKYCStub        func(string) error
	delStateWithKYCMutex       sync.RWMutex
	delStateWithKYCArgsForCall []struct {
		arg1 string
	}
	delStateWithKYCReturns struct {
		result1 error
	}
	delStateWithKYCReturnsOnCall map[int]struct {
		result1 error
	}
	DelStateWithoutKYCStub        func(string) error
	delStateWithoutKYCMutex       sync.RWMutex
	delStateWithoutKYCArgsForCall []struct {
		arg1 string
	}
	delStateWithoutKYCReturns struct {
		result1 error
	}
	delStateWithoutKYCReturnsOnCall map[int]struct {
		result1 error
	}
	GetChannelIDStub        func() string
	getChannelIDMutex       sync.RWMutex
	getChannelIDArgsForCall []struct {
	}
	getChannelIDReturns struct {
		result1 string
	}
	getChannelIDReturnsOnCall map[int]struct {
		result1 string
	}
	GetClientIdentityStub        func() cid.ClientIdentity
	getClientIdentityMutex       sync.RWMutex
	getClientIdentityArgsForCall []struct {
	}
	getClientIdentityReturns struct {
		result1 cid.ClientIdentity
	}
	getClientIdentityReturnsOnCall map[int]struct {
		result1 cid.ClientIdentity
	}
	GetFunctionAndParametersStub        func() (string, []string)
	getFunctionAndParametersMutex       sync.RWMutex
	getFunctionAndParametersArgsForCall []struct {
	}
	getFunctionAndParametersReturns struct {
		result1 string
		result2 []string
	}
	getFunctionAndParametersReturnsOnCall map[int]struct {
		result1 string
		result2 []string
	}
	GetHistoryForKeyStub        func(string) (kalpsdk.HistoryQueryIteratorInterface, error)
	getHistoryForKeyMutex       sync.RWMutex
	getHistoryForKeyArgsForCall []struct {
		arg1 string
	}
	getHistoryForKeyReturns struct {
		result1 kalpsdk.HistoryQueryIteratorInterface
		result2 error
	}
	getHistoryForKeyReturnsOnCall map[int]struct {
		result1 kalpsdk.HistoryQueryIteratorInterface
		result2 error
	}
	GetKYCStub        func(string) (bool, error)
	getKYCMutex       sync.RWMutex
	getKYCArgsForCall []struct {
		arg1 string
	}
	getKYCReturns struct {
		result1 bool
		result2 error
	}
	getKYCReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetQueryResultStub        func(string) (kalpsdk.StateQueryIteratorInterface, error)
	getQueryResultMutex       sync.RWMutex
	getQueryResultArgsForCall []struct {
		arg1 string
	}
	getQueryResultReturns struct {
		result1 kalpsdk.StateQueryIteratorInterface
		result2 error
	}
	getQueryResultReturnsOnCall map[int]struct {
		result1 kalpsdk.StateQueryIteratorInterface
		result2 error
	}
	GetSignedProposalStub        func() (*peer.SignedProposal, error)
	getSignedProposalMutex       sync.RWMutex
	getSignedProposalArgsForCall []struct {
	}
	getSignedProposalReturns struct {
		result1 *peer.SignedProposal
		result2 error
	}
	getSignedProposalReturnsOnCall map[int]struct {
		result1 *peer.SignedProposal
		result2 error
	}
	GetStateStub        func(string) ([]byte, error)
	getStateMutex       sync.RWMutex
	getStateArgsForCall []struct {
		arg1 string
	}
	getStateReturns struct {
		result1 []byte
		result2 error
	}
	getStateReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetStateByPartialCompositeKeyStub        func(string, []string) (kalpsdk.StateQueryIteratorInterface, error)
	getStateByPartialCompositeKeyMutex       sync.RWMutex
	getStateByPartialCompositeKeyArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	getStateByPartialCompositeKeyReturns struct {
		result1 kalpsdk.StateQueryIteratorInterface
		result2 error
	}
	getStateByPartialCompositeKeyReturnsOnCall map[int]struct {
		result1 kalpsdk.StateQueryIteratorInterface
		result2 error
	}
	GetStateByRangeStub        func(string, string) (kalpsdk.StateQueryIteratorInterface, error)
	getStateByRangeMutex       sync.RWMutex
	getStateByRangeArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getStateByRangeReturns struct {
		result1 kalpsdk.StateQueryIteratorInterface
		result2 error
	}
	getStateByRangeReturnsOnCall map[int]struct {
		result1 kalpsdk.StateQueryIteratorInterface
		result2 error
	}
	GetTxIDStub        func() string
	getTxIDMutex       sync.RWMutex
	getTxIDArgsForCall []struct {
	}
	getTxIDReturns struct {
		result1 string
	}
	getTxIDReturnsOnCall map[int]struct {
		result1 string
	}
	GetTxTimestampStub        func() (*timestamppb.Timestamp, error)
	getTxTimestampMutex       sync.RWMutex
	getTxTimestampArgsForCall []struct {
	}
	getTxTimestampReturns struct {
		result1 *timestamppb.Timestamp
		result2 error
	}
	getTxTimestampReturnsOnCall map[int]struct {
		result1 *timestamppb.Timestamp
		result2 error
	}
	GetUserIDStub        func() (string, error)
	getUserIDMutex       sync.RWMutex
	getUserIDArgsForCall []struct {
	}
	getUserIDReturns struct {
		result1 string
		result2 error
	}
	getUserIDReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	InvokeChaincodeStub        func(string, [][]byte, string) response.Response
	invokeChaincodeMutex       sync.RWMutex
	invokeChaincodeArgsForCall []struct {
		arg1 string
		arg2 [][]byte
		arg3 string
	}
	invokeChaincodeReturns struct {
		result1 response.Response
	}
	invokeChaincodeReturnsOnCall map[int]struct {
		result1 response.Response
	}
	PutKYCStub        func(string, string, string) error
	putKYCMutex       sync.RWMutex
	putKYCArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	putKYCReturns struct {
		result1 error
	}
	putKYCReturnsOnCall map[int]struct {
		result1 error
	}
	PutStateWithKYCStub        func(string, []byte) error
	putStateWithKYCMutex       sync.RWMutex
	putStateWithKYCArgsForCall []struct {
		arg1 string
		arg2 []byte
	}
	putStateWithKYCReturns struct {
		result1 error
	}
	putStateWithKYCReturnsOnCall map[int]struct {
		result1 error
	}
	PutStateWithoutKYCStub        func(string, []byte) error
	putStateWithoutKYCMutex       sync.RWMutex
	putStateWithoutKYCArgsForCall []struct {
		arg1 string
		arg2 []byte
	}
	putStateWithoutKYCReturns struct {
		result1 error
	}
	putStateWithoutKYCReturnsOnCall map[int]struct {
		result1 error
	}
	SetEventStub        func(string, []byte) error
	setEventMutex       sync.RWMutex
	setEventArgsForCall []struct {
		arg1 string
		arg2 []byte
	}
	setEventReturns struct {
		result1 error
	}
	setEventReturnsOnCall map[int]struct {
		result1 error
	}
	SplitCompositeKeyStub        func(string) (string, []string, error)
	splitCompositeKeyMutex       sync.RWMutex
	splitCompositeKeyArgsForCall []struct {
		arg1 string
	}
	splitCompositeKeyReturns struct {
		result1 string
		result2 []string
		result3 error
	}
	splitCompositeKeyReturnsOnCall map[int]struct {
		result1 string
		result2 []string
		result3 error
	}
	ValidateCreateTokenTransactionStub        func(string, string, []string) error
	validateCreateTokenTransactionMutex       sync.RWMutex
	validateCreateTokenTransactionArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []string
	}
	validateCreateTokenTransactionReturns struct {
		result1 error
	}
	validateCreateTokenTransactionReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *TransactionContext) CreateCompositeKey(arg1 string, arg2 []string) (string, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.createCompositeKeyMutex.Lock()
	ret, specificReturn := fake.createCompositeKeyReturnsOnCall[len(fake.createCompositeKeyArgsForCall)]
	fake.createCompositeKeyArgsForCall = append(fake.createCompositeKeyArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.CreateCompositeKeyStub
	fakeReturns := fake.createCompositeKeyReturns
	fake.recordInvocation("CreateCompositeKey", []interface{}{arg1, arg2Copy})
	fake.createCompositeKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TransactionContext) CreateCompositeKeyCallCount() int {
	fake.createCompositeKeyMutex.RLock()
	defer fake.createCompositeKeyMutex.RUnlock()
	return len(fake.createCompositeKeyArgsForCall)
}

func (fake *TransactionContext) CreateCompositeKeyCalls(stub func(string, []string) (string, error)) {
	fake.createCompositeKeyMutex.Lock()
	defer fake.createCompositeKeyMutex.Unlock()
	fake.CreateCompositeKeyStub = stub
}

func (fake *TransactionContext) CreateCompositeKeyArgsForCall(i int) (string, []string) {
	fake.createCompositeKeyMutex.RLock()
	defer fake.createCompositeKeyMutex.RUnlock()
	argsForCall := fake.createCompositeKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TransactionContext) CreateCompositeKeyReturns(result1 string, result2 error) {
	fake.createCompositeKeyMutex.Lock()
	defer fake.createCompositeKeyMutex.Unlock()
	fake.CreateCompositeKeyStub = nil
	fake.createCompositeKeyReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) CreateCompositeKeyReturnsOnCall(i int, result1 string, result2 error) {
	fake.createCompositeKeyMutex.Lock()
	defer fake.createCompositeKeyMutex.Unlock()
	fake.CreateCompositeKeyStub = nil
	if fake.createCompositeKeyReturnsOnCall == nil {
		fake.createCompositeKeyReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createCompositeKeyReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) DelStateWithKYC(arg1 string) error {
	fake.delStateWithKYCMutex.Lock()
	ret, specificReturn := fake.delStateWithKYCReturnsOnCall[len(fake.delStateWithKYCArgsForCall)]
	fake.delStateWithKYCArgsForCall = append(fake.delStateWithKYCArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DelStateWithKYCStub
	fakeReturns := fake.delStateWithKYCReturns
	fake.recordInvocation("DelStateWithKYC", []interface{}{arg1})
	fake.delStateWithKYCMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TransactionContext) DelStateWithKYCCallCount() int {
	fake.delStateWithKYCMutex.RLock()
	defer fake.delStateWithKYCMutex.RUnlock()
	return len(fake.delStateWithKYCArgsForCall)
}

func (fake *TransactionContext) DelStateWithKYCCalls(stub func(string) error) {
	fake.delStateWithKYCMutex.Lock()
	defer fake.delStateWithKYCMutex.Unlock()
	fake.DelStateWithKYCStub = stub
}

func (fake *TransactionContext) DelStateWithKYCArgsForCall(i int) string {
	fake.delStateWithKYCMutex.RLock()
	defer fake.delStateWithKYCMutex.RUnlock()
	argsForCall := fake.delStateWithKYCArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TransactionContext) DelStateWithKYCReturns(result1 error) {
	fake.delStateWithKYCMutex.Lock()
	defer fake.delStateWithKYCMutex.Unlock()
	fake.DelStateWithKYCStub = nil
	fake.delStateWithKYCReturns = struct {
		result1 error
	}{result1}
}

func (fake *TransactionContext) DelStateWithKYCReturnsOnCall(i int, result1 error) {
	fake.delStateWithKYCMutex.Lock()
	defer fake.delStateWithKYCMutex.Unlock()
	fake.DelStateWithKYCStub = nil
	if fake.delStateWithKYCReturnsOnCall == nil {
		fake.delStateWithKYCReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.delStateWithKYCReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TransactionContext) DelStateWithoutKYC(arg1 string) error {
	fake.delStateWithoutKYCMutex.Lock()
	ret, specificReturn := fake.delStateWithoutKYCReturnsOnCall[len(fake.delStateWithoutKYCArgsForCall)]
	fake.delStateWithoutKYCArgsForCall = append(fake.delStateWithoutKYCArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DelStateWithoutKYCStub
	fakeReturns := fake.delStateWithoutKYCReturns
	fake.recordInvocation("DelStateWithoutKYC", []interface{}{arg1})
	fake.delStateWithoutKYCMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TransactionContext) DelStateWithoutKYCCallCount() int {
	fake.delStateWithoutKYCMutex.RLock()
	defer fake.delStateWithoutKYCMutex.RUnlock()
	return len(fake.delStateWithoutKYCArgsForCall)
}

func (fake *TransactionContext) DelStateWithoutKYCCalls(stub func(string) error) {
	fake.delStateWithoutKYCMutex.Lock()
	defer fake.delStateWithoutKYCMutex.Unlock()
	fake.DelStateWithoutKYCStub = stub
}

func (fake *TransactionContext) DelStateWithoutKYCArgsForCall(i int) string {
	fake.delStateWithoutKYCMutex.RLock()
	defer fake.delStateWithoutKYCMutex.RUnlock()
	argsForCall := fake.delStateWithoutKYCArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TransactionContext) DelStateWithoutKYCReturns(result1 error) {
	fake.delStateWithoutKYCMutex.Lock()
	defer fake.delStateWithoutKYCMutex.Unlock()
	fake.DelStateWithoutKYCStub = nil
	fake.delStateWithoutKYCReturns = struct {
		result1 error
	}{result1}
}

func (fake *TransactionContext) DelStateWithoutKYCReturnsOnCall(i int, result1 error) {
	fake.delStateWithoutKYCMutex.Lock()
	defer fake.delStateWithoutKYCMutex.Unlock()
	fake.DelStateWithoutKYCStub = nil
	if fake.delStateWithoutKYCReturnsOnCall == nil {
		fake.delStateWithoutKYCReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.delStateWithoutKYCReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TransactionContext) GetChannelID() string {
	fake.getChannelIDMutex.Lock()
	ret, specificReturn := fake.getChannelIDReturnsOnCall[len(fake.getChannelIDArgsForCall)]
	fake.getChannelIDArgsForCall = append(fake.getChannelIDArgsForCall, struct {
	}{})
	stub := fake.GetChannelIDStub
	fakeReturns := fake.getChannelIDReturns
	fake.recordInvocation("GetChannelID", []interface{}{})
	fake.getChannelIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TransactionContext) GetChannelIDCallCount() int {
	fake.getChannelIDMutex.RLock()
	defer fake.getChannelIDMutex.RUnlock()
	return len(fake.getChannelIDArgsForCall)
}

func (fake *TransactionContext) GetChannelIDCalls(stub func() string) {
	fake.getChannelIDMutex.Lock()
	defer fake.getChannelIDMutex.Unlock()
	fake.GetChannelIDStub = stub
}

func (fake *TransactionContext) GetChannelIDReturns(result1 string) {
	fake.getChannelIDMutex.Lock()
	defer fake.getChannelIDMutex.Unlock()
	fake.GetChannelIDStub = nil
	fake.getChannelIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *TransactionContext) GetChannelIDReturnsOnCall(i int, result1 string) {
	fake.getChannelIDMutex.Lock()
	defer fake.getChannelIDMutex.Unlock()
	fake.GetChannelIDStub = nil
	if fake.getChannelIDReturnsOnCall == nil {
		fake.getChannelIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getChannelIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *TransactionContext) GetClientIdentity() cid.ClientIdentity {
	fake.getClientIdentityMutex.Lock()
	ret, specificReturn := fake.getClientIdentityReturnsOnCall[len(fake.getClientIdentityArgsForCall)]
	fake.getClientIdentityArgsForCall = append(fake.getClientIdentityArgsForCall, struct {
	}{})
	stub := fake.GetClientIdentityStub
	fakeReturns := fake.getClientIdentityReturns
	fake.recordInvocation("GetClientIdentity", []interface{}{})
	fake.getClientIdentityMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TransactionContext) GetClientIdentityCallCount() int {
	fake.getClientIdentityMutex.RLock()
	defer fake.getClientIdentityMutex.RUnlock()
	return len(fake.getClientIdentityArgsForCall)
}

func (fake *TransactionContext) GetClientIdentityCalls(stub func() cid.ClientIdentity) {
	fake.getClientIdentityMutex.Lock()
	defer fake.getClientIdentityMutex.Unlock()
	fake.GetClientIdentityStub = stub
}

func (fake *TransactionContext) GetClientIdentityReturns(result1 cid.ClientIdentity) {
	fake.getClientIdentityMutex.Lock()
	defer fake.getClientIdentityMutex.Unlock()
	fake.GetClientIdentityStub = nil
	fake.getClientIdentityReturns = struct {
		result1 cid.ClientIdentity
	}{result1}
}

func (fake *TransactionContext) GetClientIdentityReturnsOnCall(i int, result1 cid.ClientIdentity) {
	fake.getClientIdentityMutex.Lock()
	defer fake.getClientIdentityMutex.Unlock()
	fake.GetClientIdentityStub = nil
	if fake.getClientIdentityReturnsOnCall == nil {
		fake.getClientIdentityReturnsOnCall = make(map[int]struct {
			result1 cid.ClientIdentity
		})
	}
	fake.getClientIdentityReturnsOnCall[i] = struct {
		result1 cid.ClientIdentity
	}{result1}
}

func (fake *TransactionContext) GetFunctionAndParameters() (string, []string) {
	fake.getFunctionAndParametersMutex.Lock()
	ret, specificReturn := fake.getFunctionAndParametersReturnsOnCall[len(fake.getFunctionAndParametersArgsForCall)]
	fake.getFunctionAndParametersArgsForCall = append(fake.getFunctionAndParametersArgsForCall, struct {
	}{})
	stub := fake.GetFunctionAndParametersStub
	fakeReturns := fake.getFunctionAndParametersReturns
	fake.recordInvocation("GetFunctionAndParameters", []interface{}{})
	fake.getFunctionAndParametersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TransactionContext) GetFunctionAndParametersCallCount() int {
	fake.getFunctionAndParametersMutex.RLock()
	defer fake.getFunctionAndParametersMutex.RUnlock()
	return len(fake.getFunctionAndParametersArgsForCall)
}

func (fake *TransactionContext) GetFunctionAndParametersCalls(stub func() (string, []string)) {
	fake.getFunctionAndParametersMutex.Lock()
	defer fake.getFunctionAndParametersMutex.Unlock()
	fake.GetFunctionAndParametersStub = stub
}

func (fake *TransactionContext) GetFunctionAndParametersReturns(result1 string, result2 []string) {
	fake.getFunctionAndParametersMutex.Lock()
	defer fake.getFunctionAndParametersMutex.Unlock()
	fake.GetFunctionAndParametersStub = nil
	fake.getFunctionAndParametersReturns = struct {
		result1 string
		result2 []string
	}{result1, result2}
}

func (fake *TransactionContext) GetFunctionAndParametersReturnsOnCall(i int, result1 string, result2 []string) {
	fake.getFunctionAndParametersMutex.Lock()
	defer fake.getFunctionAndParametersMutex.Unlock()
	fake.GetFunctionAndParametersStub = nil
	if fake.getFunctionAndParametersReturnsOnCall == nil {
		fake.getFunctionAndParametersReturnsOnCall = make(map[int]struct {
			result1 string
			result2 []string
		})
	}
	fake.getFunctionAndParametersReturnsOnCall[i] = struct {
		result1 string
		result2 []string
	}{result1, result2}
}

func (fake *TransactionContext) GetHistoryForKey(arg1 string) (kalpsdk.HistoryQueryIteratorInterface, error) {
	fake.getHistoryForKeyMutex.Lock()
	ret, specificReturn := fake.getHistoryForKeyReturnsOnCall[len(fake.getHistoryForKeyArgsForCall)]
	fake.getHistoryForKeyArgsForCall = append(fake.getHistoryForKeyArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetHistoryForKeyStub
	fakeReturns := fake.getHistoryForKeyReturns
	fake.recordInvocation("GetHistoryForKey", []interface{}{arg1})
	fake.getHistoryForKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TransactionContext) GetHistoryForKeyCallCount() int {
	fake.getHistoryForKeyMutex.RLock()
	defer fake.getHistoryForKeyMutex.RUnlock()
	return len(fake.getHistoryForKeyArgsForCall)
}

func (fake *TransactionContext) GetHistoryForKeyCalls(stub func(string) (kalpsdk.HistoryQueryIteratorInterface, error)) {
	fake.getHistoryForKeyMutex.Lock()
	defer fake.getHistoryForKeyMutex.Unlock()
	fake.GetHistoryForKeyStub = stub
}

func (fake *TransactionContext) GetHistoryForKeyArgsForCall(i int) string {
	fake.getHistoryForKeyMutex.RLock()
	defer fake.getHistoryForKeyMutex.RUnlock()
	argsForCall := fake.getHistoryForKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TransactionContext) GetHistoryForKeyReturns(result1 kalpsdk.HistoryQueryIteratorInterface, result2 error) {
	fake.getHistoryForKeyMutex.Lock()
	defer fake.getHistoryForKeyMutex.Unlock()
	fake.GetHistoryForKeyStub = nil
	fake.getHistoryForKeyReturns = struct {
		result1 kalpsdk.HistoryQueryIteratorInterface
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetHistoryForKeyReturnsOnCall(i int, result1 kalpsdk.HistoryQueryIteratorInterface, result2 error) {
	fake.getHistoryForKeyMutex.Lock()
	defer fake.getHistoryForKeyMutex.Unlock()
	fake.GetHistoryForKeyStub = nil
	if fake.getHistoryForKeyReturnsOnCall == nil {
		fake.getHistoryForKeyReturnsOnCall = make(map[int]struct {
			result1 kalpsdk.HistoryQueryIteratorInterface
			result2 error
		})
	}
	fake.getHistoryForKeyReturnsOnCall[i] = struct {
		result1 kalpsdk.HistoryQueryIteratorInterface
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetKYC(arg1 string) (bool, error) {
	fake.getKYCMutex.Lock()
	ret, specificReturn := fake.getKYCReturnsOnCall[len(fake.getKYCArgsForCall)]
	fake.getKYCArgsForCall = append(fake.getKYCArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetKYCStub
	fakeReturns := fake.getKYCReturns
	fake.recordInvocation("GetKYC", []interface{}{arg1})
	fake.getKYCMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TransactionContext) GetKYCCallCount() int {
	fake.getKYCMutex.RLock()
	defer fake.getKYCMutex.RUnlock()
	return len(fake.getKYCArgsForCall)
}

func (fake *TransactionContext) GetKYCCalls(stub func(string) (bool, error)) {
	fake.getKYCMutex.Lock()
	defer fake.getKYCMutex.Unlock()
	fake.GetKYCStub = stub
}

func (fake *TransactionContext) GetKYCArgsForCall(i int) string {
	fake.getKYCMutex.RLock()
	defer fake.getKYCMutex.RUnlock()
	argsForCall := fake.getKYCArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TransactionContext) GetKYCReturns(result1 bool, result2 error) {
	fake.getKYCMutex.Lock()
	defer fake.getKYCMutex.Unlock()
	fake.GetKYCStub = nil
	fake.getKYCReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetKYCReturnsOnCall(i int, result1 bool, result2 error) {
	fake.getKYCMutex.Lock()
	defer fake.getKYCMutex.Unlock()
	fake.GetKYCStub = nil
	if fake.getKYCReturnsOnCall == nil {
		fake.getKYCReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.getKYCReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetQueryResult(arg1 string) (kalpsdk.StateQueryIteratorInterface, error) {
	fake.getQueryResultMutex.Lock()
	ret, specificReturn := fake.getQueryResultReturnsOnCall[len(fake.getQueryResultArgsForCall)]
	fake.getQueryResultArgsForCall = append(fake.getQueryResultArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetQueryResultStub
	fakeReturns := fake.getQueryResultReturns
	fake.recordInvocation("GetQueryResult", []interface{}{arg1})
	fake.getQueryResultMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TransactionContext) GetQueryResultCallCount() int {
	fake.getQueryResultMutex.RLock()
	defer fake.getQueryResultMutex.RUnlock()
	return len(fake.getQueryResultArgsForCall)
}

func (fake *TransactionContext) GetQueryResultCalls(stub func(string) (kalpsdk.StateQueryIteratorInterface, error)) {
	fake.getQueryResultMutex.Lock()
	defer fake.getQueryResultMutex.Unlock()
	fake.GetQueryResultStub = stub
}

func (fake *TransactionContext) GetQueryResultArgsForCall(i int) string {
	fake.getQueryResultMutex.RLock()
	defer fake.getQueryResultMutex.RUnlock()
	argsForCall := fake.getQueryResultArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TransactionContext) GetQueryResultReturns(result1 kalpsdk.StateQueryIteratorInterface, result2 error) {
	fake.getQueryResultMutex.Lock()
	defer fake.getQueryResultMutex.Unlock()
	fake.GetQueryResultStub = nil
	fake.getQueryResultReturns = struct {
		result1 kalpsdk.StateQueryIteratorInterface
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetQueryResultReturnsOnCall(i int, result1 kalpsdk.StateQueryIteratorInterface, result2 error) {
	fake.getQueryResultMutex.Lock()
	defer fake.getQueryResultMutex.Unlock()
	fake.GetQueryResultStub = nil
	if fake.getQueryResultReturnsOnCall == nil {
		fake.getQueryResultReturnsOnCall = make(map[int]struct {
			result1 kalpsdk.StateQueryIteratorInterface
			result2 error
		})
	}
	fake.getQueryResultReturnsOnCall[i] = struct {
		result1 kalpsdk.StateQueryIteratorInterface
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetSignedProposal() (*peer.SignedProposal, error) {
	fake.getSignedProposalMutex.Lock()
	ret, specificReturn := fake.getSignedProposalReturnsOnCall[len(fake.getSignedProposalArgsForCall)]
	fake.getSignedProposalArgsForCall = append(fake.getSignedProposalArgsForCall, struct {
	}{})
	stub := fake.GetSignedProposalStub
	fakeReturns := fake.getSignedProposalReturns
	fake.recordInvocation("GetSignedProposal", []interface{}{})
	fake.getSignedProposalMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TransactionContext) GetSignedProposalCallCount() int {
	fake.getSignedProposalMutex.RLock()
	defer fake.getSignedProposalMutex.RUnlock()
	return len(fake.getSignedProposalArgsForCall)
}

func (fake *TransactionContext) GetSignedProposalCalls(stub func() (*peer.SignedProposal, error)) {
	fake.getSignedProposalMutex.Lock()
	defer fake.getSignedProposalMutex.Unlock()
	fake.GetSignedProposalStub = stub
}

func (fake *TransactionContext) GetSignedProposalReturns(result1 *peer.SignedProposal, result2 error) {
	fake.getSignedProposalMutex.Lock()
	defer fake.getSignedProposalMutex.Unlock()
	fake.GetSignedProposalStub = nil
	fake.getSignedProposalReturns = struct {
		result1 *peer.SignedProposal
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetSignedProposalReturnsOnCall(i int, result1 *peer.SignedProposal, result2 error) {
	fake.getSignedProposalMutex.Lock()
	defer fake.getSignedProposalMutex.Unlock()
	fake.GetSignedProposalStub = nil
	if fake.getSignedProposalReturnsOnCall == nil {
		fake.getSignedProposalReturnsOnCall = make(map[int]struct {
			result1 *peer.SignedProposal
			result2 error
		})
	}
	fake.getSignedProposalReturnsOnCall[i] = struct {
		result1 *peer.SignedProposal
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetState(arg1 string) ([]byte, error) {
	fake.getStateMutex.Lock()
	ret, specificReturn := fake.getStateReturnsOnCall[len(fake.getStateArgsForCall)]
	fake.getStateArgsForCall = append(fake.getStateArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStateStub
	fakeReturns := fake.getStateReturns
	fake.recordInvocation("GetState", []interface{}{arg1})
	fake.getStateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TransactionContext) GetStateCallCount() int {
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	return len(fake.getStateArgsForCall)
}

func (fake *TransactionContext) GetStateCalls(stub func(string) ([]byte, error)) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = stub
}

func (fake *TransactionContext) GetStateArgsForCall(i int) string {
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	argsForCall := fake.getStateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TransactionContext) GetStateReturns(result1 []byte, result2 error) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = nil
	fake.getStateReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetStateReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.getStateMutex.Lock()
	defer fake.getStateMutex.Unlock()
	fake.GetStateStub = nil
	if fake.getStateReturnsOnCall == nil {
		fake.getStateReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getStateReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetStateByPartialCompositeKey(arg1 string, arg2 []string) (kalpsdk.StateQueryIteratorInterface, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.getStateByPartialCompositeKeyMutex.Lock()
	ret, specificReturn := fake.getStateByPartialCompositeKeyReturnsOnCall[len(fake.getStateByPartialCompositeKeyArgsForCall)]
	fake.getStateByPartialCompositeKeyArgsForCall = append(fake.getStateByPartialCompositeKeyArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.GetStateByPartialCompositeKeyStub
	fakeReturns := fake.getStateByPartialCompositeKeyReturns
	fake.recordInvocation("GetStateByPartialCompositeKey", []interface{}{arg1, arg2Copy})
	fake.getStateByPartialCompositeKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TransactionContext) GetStateByPartialCompositeKeyCallCount() int {
	fake.getStateByPartialCompositeKeyMutex.RLock()
	defer fake.getStateByPartialCompositeKeyMutex.RUnlock()
	return len(fake.getStateByPartialCompositeKeyArgsForCall)
}

func (fake *TransactionContext) GetStateByPartialCompositeKeyCalls(stub func(string, []string) (kalpsdk.StateQueryIteratorInterface, error)) {
	fake.getStateByPartialCompositeKeyMutex.Lock()
	defer fake.getStateByPartialCompositeKeyMutex.Unlock()
	fake.GetStateByPartialCompositeKeyStub = stub
}

func (fake *TransactionContext) GetStateByPartialCompositeKeyArgsForCall(i int) (string, []string) {
	fake.getStateByPartialCompositeKeyMutex.RLock()
	defer fake.getStateByPartialCompositeKeyMutex.RUnlock()
	argsForCall := fake.getStateByPartialCompositeKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TransactionContext) GetStateByPartialCompositeKeyReturns(result1 kalpsdk.StateQueryIteratorInterface, result2 error) {
	fake.getStateByPartialCompositeKeyMutex.Lock()
	defer fake.getStateByPartialCompositeKeyMutex.Unlock()
	fake.GetStateByPartialCompositeKeyStub = nil
	fake.getStateByPartialCompositeKeyReturns = struct {
		result1 kalpsdk.StateQueryIteratorInterface
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetStateByPartialCompositeKeyReturnsOnCall(i int, result1 kalpsdk.StateQueryIteratorInterface, result2 error) {
	fake.getStateByPartialCompositeKeyMutex.Lock()
	defer fake.getStateByPartialCompositeKeyMutex.Unlock()
	fake.GetStateByPartialCompositeKeyStub = nil
	if fake.getStateByPartialCompositeKeyReturnsOnCall == nil {
		fake.getStateByPartialCompositeKeyReturnsOnCall = make(map[int]struct {
			result1 kalpsdk.StateQueryIteratorInterface
			result2 error
		})
	}
	fake.getStateByPartialCompositeKeyReturnsOnCall[i] = struct {
		result1 kalpsdk.StateQueryIteratorInterface
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetStateByRange(arg1 string, arg2 string) (kalpsdk.StateQueryIteratorInterface, error) {
	fake.getStateByRangeMutex.Lock()
	ret, specificReturn := fake.getStateByRangeReturnsOnCall[len(fake.getStateByRangeArgsForCall)]
	fake.getStateByRangeArgsForCall = append(fake.getStateByRangeArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetStateByRangeStub
	fakeReturns := fake.getStateByRangeReturns
	fake.recordInvocation("GetStateByRange", []interface{}{arg1, arg2})
	fake.getStateByRangeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TransactionContext) GetStateByRangeCallCount() int {
	fake.getStateByRangeMutex.RLock()
	defer fake.getStateByRangeMutex.RUnlock()
	return len(fake.getStateByRangeArgsForCall)
}

func (fake *TransactionContext) GetStateByRangeCalls(stub func(string, string) (kalpsdk.StateQueryIteratorInterface, error)) {
	fake.getStateByRangeMutex.Lock()
	defer fake.getStateByRangeMutex.Unlock()
	fake.GetStateByRangeStub = stub
}

func (fake *TransactionContext) GetStateByRangeArgsForCall(i int) (string, string) {
	fake.getStateByRangeMutex.RLock()
	defer fake.getStateByRangeMutex.RUnlock()
	argsForCall := fake.getStateByRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TransactionContext) GetStateByRangeReturns(result1 kalpsdk.StateQueryIteratorInterface, result2 error) {
	fake.getStateByRangeMutex.Lock()
	defer fake.getStateByRangeMutex.Unlock()
	fake.GetStateByRangeStub = nil
	fake.getStateByRangeReturns = struct {
		result1 kalpsdk.StateQueryIteratorInterface
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetStateByRangeReturnsOnCall(i int, result1 kalpsdk.StateQueryIteratorInterface, result2 error) {
	fake.getStateByRangeMutex.Lock()
	defer fake.getStateByRangeMutex.Unlock()
	fake.GetStateByRangeStub = nil
	if fake.getStateByRangeReturnsOnCall == nil {
		fake.getStateByRangeReturnsOnCall = make(map[int]struct {
			result1 kalpsdk.StateQueryIteratorInterface
			result2 error
		})
	}
	fake.getStateByRangeReturnsOnCall[i] = struct {
		result1 kalpsdk.StateQueryIteratorInterface
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetTxID() string {
	fake.getTxIDMutex.Lock()
	ret, specificReturn := fake.getTxIDReturnsOnCall[len(fake.getTxIDArgsForCall)]
	fake.getTxIDArgsForCall = append(fake.getTxIDArgsForCall, struct {
	}{})
	stub := fake.GetTxIDStub
	fakeReturns := fake.getTxIDReturns
	fake.recordInvocation("GetTxID", []interface{}{})
	fake.getTxIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TransactionContext) GetTxIDCallCount() int {
	fake.getTxIDMutex.RLock()
	defer fake.getTxIDMutex.RUnlock()
	return len(fake.getTxIDArgsForCall)
}

func (fake *TransactionContext) GetTxIDCalls(stub func() string) {
	fake.getTxIDMutex.Lock()
	defer fake.getTxIDMutex.Unlock()
	fake.GetTxIDStub = stub
}

func (fake *TransactionContext) GetTxIDReturns(result1 string) {
	fake.getTxIDMutex.Lock()
	defer fake.getTxIDMutex.Unlock()
	fake.GetTxIDStub = nil
	fake.getTxIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *TransactionContext) GetTxIDReturnsOnCall(i int, result1 string) {
	fake.getTxIDMutex.Lock()
	defer fake.getTxIDMutex.Unlock()
	fake.GetTxIDStub = nil
	if fake.getTxIDReturnsOnCall == nil {
		fake.getTxIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getTxIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *TransactionContext) GetTxTimestamp() (*timestamppb.Timestamp, error) {
	fake.getTxTimestampMutex.Lock()
	ret, specificReturn := fake.getTxTimestampReturnsOnCall[len(fake.getTxTimestampArgsForCall)]
	fake.getTxTimestampArgsForCall = append(fake.getTxTimestampArgsForCall, struct {
	}{})
	stub := fake.GetTxTimestampStub
	fakeReturns := fake.getTxTimestampReturns
	fake.recordInvocation("GetTxTimestamp", []interface{}{})
	fake.getTxTimestampMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TransactionContext) GetTxTimestampCallCount() int {
	fake.getTxTimestampMutex.RLock()
	defer fake.getTxTimestampMutex.RUnlock()
	return len(fake.getTxTimestampArgsForCall)
}

func (fake *TransactionContext) GetTxTimestampCalls(stub func() (*timestamppb.Timestamp, error)) {
	fake.getTxTimestampMutex.Lock()
	defer fake.getTxTimestampMutex.Unlock()
	fake.GetTxTimestampStub = stub
}

func (fake *TransactionContext) GetTxTimestampReturns(result1 *timestamppb.Timestamp, result2 error) {
	fake.getTxTimestampMutex.Lock()
	defer fake.getTxTimestampMutex.Unlock()
	fake.GetTxTimestampStub = nil
	fake.getTxTimestampReturns = struct {
		result1 *timestamppb.Timestamp
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetTxTimestampReturnsOnCall(i int, result1 *timestamppb.Timestamp, result2 error) {
	fake.getTxTimestampMutex.Lock()
	defer fake.getTxTimestampMutex.Unlock()
	fake.GetTxTimestampStub = nil
	if fake.getTxTimestampReturnsOnCall == nil {
		fake.getTxTimestampReturnsOnCall = make(map[int]struct {
			result1 *timestamppb.Timestamp
			result2 error
		})
	}
	fake.getTxTimestampReturnsOnCall[i] = struct {
		result1 *timestamppb.Timestamp
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetUserID() (string, error) {
	fake.getUserIDMutex.Lock()
	ret, specificReturn := fake.getUserIDReturnsOnCall[len(fake.getUserIDArgsForCall)]
	fake.getUserIDArgsForCall = append(fake.getUserIDArgsForCall, struct {
	}{})
	stub := fake.GetUserIDStub
	fakeReturns := fake.getUserIDReturns
	fake.recordInvocation("GetUserID", []interface{}{})
	fake.getUserIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *TransactionContext) GetUserIDCallCount() int {
	fake.getUserIDMutex.RLock()
	defer fake.getUserIDMutex.RUnlock()
	return len(fake.getUserIDArgsForCall)
}

func (fake *TransactionContext) GetUserIDCalls(stub func() (string, error)) {
	fake.getUserIDMutex.Lock()
	defer fake.getUserIDMutex.Unlock()
	fake.GetUserIDStub = stub
}

func (fake *TransactionContext) GetUserIDReturns(result1 string, result2 error) {
	fake.getUserIDMutex.Lock()
	defer fake.getUserIDMutex.Unlock()
	fake.GetUserIDStub = nil
	fake.getUserIDReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) GetUserIDReturnsOnCall(i int, result1 string, result2 error) {
	fake.getUserIDMutex.Lock()
	defer fake.getUserIDMutex.Unlock()
	fake.GetUserIDStub = nil
	if fake.getUserIDReturnsOnCall == nil {
		fake.getUserIDReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getUserIDReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *TransactionContext) InvokeChaincode(arg1 string, arg2 [][]byte, arg3 string) response.Response {
	var arg2Copy [][]byte
	if arg2 != nil {
		arg2Copy = make([][]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.invokeChaincodeMutex.Lock()
	ret, specificReturn := fake.invokeChaincodeReturnsOnCall[len(fake.invokeChaincodeArgsForCall)]
	fake.invokeChaincodeArgsForCall = append(fake.invokeChaincodeArgsForCall, struct {
		arg1 string
		arg2 [][]byte
		arg3 string
	}{arg1, arg2Copy, arg3})
	stub := fake.InvokeChaincodeStub
	fakeReturns := fake.invokeChaincodeReturns
	fake.recordInvocation("InvokeChaincode", []interface{}{arg1, arg2Copy, arg3})
	fake.invokeChaincodeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TransactionContext) InvokeChaincodeCallCount() int {
	fake.invokeChaincodeMutex.RLock()
	defer fake.invokeChaincodeMutex.RUnlock()
	return len(fake.invokeChaincodeArgsForCall)
}

func (fake *TransactionContext) InvokeChaincodeCalls(stub func(string, [][]byte, string) response.Response) {
	fake.invokeChaincodeMutex.Lock()
	defer fake.invokeChaincodeMutex.Unlock()
	fake.InvokeChaincodeStub = stub
}

func (fake *TransactionContext) InvokeChaincodeArgsForCall(i int) (string, [][]byte, string) {
	fake.invokeChaincodeMutex.RLock()
	defer fake.invokeChaincodeMutex.RUnlock()
	argsForCall := fake.invokeChaincodeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *TransactionContext) InvokeChaincodeReturns(result1 response.Response) {
	fake.invokeChaincodeMutex.Lock()
	defer fake.invokeChaincodeMutex.Unlock()
	fake.InvokeChaincodeStub = nil
	fake.invokeChaincodeReturns = struct {
		result1 response.Response
	}{result1}
}

func (fake *TransactionContext) InvokeChaincodeReturnsOnCall(i int, result1 response.Response) {
	fake.invokeChaincodeMutex.Lock()
	defer fake.invokeChaincodeMutex.Unlock()
	fake.InvokeChaincodeStub = nil
	if fake.invokeChaincodeReturnsOnCall == nil {
		fake.invokeChaincodeReturnsOnCall = make(map[int]struct {
			result1 response.Response
		})
	}
	fake.invokeChaincodeReturnsOnCall[i] = struct {
		result1 response.Response
	}{result1}
}

func (fake *TransactionContext) PutKYC(arg1 string, arg2 string, arg3 string) error {
	fake.putKYCMutex.Lock()
	ret, specificReturn := fake.putKYCReturnsOnCall[len(fake.putKYCArgsForCall)]
	fake.putKYCArgsForCall = append(fake.putKYCArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.PutKYCStub
	fakeReturns := fake.putKYCReturns
	fake.recordInvocation("PutKYC", []interface{}{arg1, arg2, arg3})
	fake.putKYCMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TransactionContext) PutKYCCallCount() int {
	fake.putKYCMutex.RLock()
	defer fake.putKYCMutex.RUnlock()
	return len(fake.putKYCArgsForCall)
}

func (fake *TransactionContext) PutKYCCalls(stub func(string, string, string) error) {
	fake.putKYCMutex.Lock()
	defer fake.putKYCMutex.Unlock()
	fake.PutKYCStub = stub
}

func (fake *TransactionContext) PutKYCArgsForCall(i int) (string, string, string) {
	fake.putKYCMutex.RLock()
	defer fake.putKYCMutex.RUnlock()
	argsForCall := fake.putKYCArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *TransactionContext) PutKYCReturns(result1 error) {
	fake.putKYCMutex.Lock()
	defer fake.putKYCMutex.Unlock()
	fake.PutKYCStub = nil
	fake.putKYCReturns = struct {
		result1 error
	}{result1}
}

func (fake *TransactionContext) PutKYCReturnsOnCall(i int, result1 error) {
	fake.putKYCMutex.Lock()
	defer fake.putKYCMutex.Unlock()
	fake.PutKYCStub = nil
	if fake.putKYCReturnsOnCall == nil {
		fake.putKYCReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putKYCReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TransactionContext) PutStateWithKYC(arg1 string, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.putStateWithKYCMutex.Lock()
	ret, specificReturn := fake.putStateWithKYCReturnsOnCall[len(fake.putStateWithKYCArgsForCall)]
	fake.putStateWithKYCArgsForCall = append(fake.putStateWithKYCArgsForCall, struct {
		arg1 string
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.PutStateWithKYCStub
	fakeReturns := fake.putStateWithKYCReturns
	fake.recordInvocation("PutStateWithKYC", []interface{}{arg1, arg2Copy})
	fake.putStateWithKYCMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TransactionContext) PutStateWithKYCCallCount() int {
	fake.putStateWithKYCMutex.RLock()
	defer fake.putStateWithKYCMutex.RUnlock()
	return len(fake.putStateWithKYCArgsForCall)
}

func (fake *TransactionContext) PutStateWithKYCCalls(stub func(string, []byte) error) {
	fake.putStateWithKYCMutex.Lock()
	defer fake.putStateWithKYCMutex.Unlock()
	fake.PutStateWithKYCStub = stub
}

func (fake *TransactionContext) PutStateWithKYCArgsForCall(i int) (string, []byte) {
	fake.putStateWithKYCMutex.RLock()
	defer fake.putStateWithKYCMutex.RUnlock()
	argsForCall := fake.putStateWithKYCArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TransactionContext) PutStateWithKYCReturns(result1 error) {
	fake.putStateWithKYCMutex.Lock()
	defer fake.putStateWithKYCMutex.Unlock()
	fake.PutStateWithKYCStub = nil
	fake.putStateWithKYCReturns = struct {
		result1 error
	}{result1}
}

func (fake *TransactionContext) PutStateWithKYCReturnsOnCall(i int, result1 error) {
	fake.putStateWithKYCMutex.Lock()
	defer fake.putStateWithKYCMutex.Unlock()
	fake.PutStateWithKYCStub = nil
	if fake.putStateWithKYCReturnsOnCall == nil {
		fake.putStateWithKYCReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putStateWithKYCReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TransactionContext) PutStateWithoutKYC(arg1 string, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.putStateWithoutKYCMutex.Lock()
	ret, specificReturn := fake.putStateWithoutKYCReturnsOnCall[len(fake.putStateWithoutKYCArgsForCall)]
	fake.putStateWithoutKYCArgsForCall = append(fake.putStateWithoutKYCArgsForCall, struct {
		arg1 string
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.PutStateWithoutKYCStub
	fakeReturns := fake.putStateWithoutKYCReturns
	fake.recordInvocation("PutStateWithoutKYC", []interface{}{arg1, arg2Copy})
	fake.putStateWithoutKYCMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TransactionContext) PutStateWithoutKYCCallCount() int {
	fake.putStateWithoutKYCMutex.RLock()
	defer fake.putStateWithoutKYCMutex.RUnlock()
	return len(fake.putStateWithoutKYCArgsForCall)
}

func (fake *TransactionContext) PutStateWithoutKYCCalls(stub func(string, []byte) error) {
	fake.putStateWithoutKYCMutex.Lock()
	defer fake.putStateWithoutKYCMutex.Unlock()
	fake.PutStateWithoutKYCStub = stub
}

func (fake *TransactionContext) PutStateWithoutKYCArgsForCall(i int) (string, []byte) {
	fake.putStateWithoutKYCMutex.RLock()
	defer fake.putStateWithoutKYCMutex.RUnlock()
	argsForCall := fake.putStateWithoutKYCArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TransactionContext) PutStateWithoutKYCReturns(result1 error) {
	fake.putStateWithoutKYCMutex.Lock()
	defer fake.putStateWithoutKYCMutex.Unlock()
	fake.PutStateWithoutKYCStub = nil
	fake.putStateWithoutKYCReturns = struct {
		result1 error
	}{result1}
}

func (fake *TransactionContext) PutStateWithoutKYCReturnsOnCall(i int, result1 error) {
	fake.putStateWithoutKYCMutex.Lock()
	defer fake.putStateWithoutKYCMutex.Unlock()
	fake.PutStateWithoutKYCStub = nil
	if fake.putStateWithoutKYCReturnsOnCall == nil {
		fake.putStateWithoutKYCReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putStateWithoutKYCReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TransactionContext) SetEvent(arg1 string, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.setEventMutex.Lock()
	ret, specificReturn := fake.setEventReturnsOnCall[len(fake.setEventArgsForCall)]
	fake.setEventArgsForCall = append(fake.setEventArgsForCall, struct {
		arg1 string
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.SetEventStub
	fakeReturns := fake.setEventReturns
	fake.recordInvocation("SetEvent", []interface{}{arg1, arg2Copy})
	fake.setEventMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TransactionContext) SetEventCallCount() int {
	fake.setEventMutex.RLock()
	defer fake.setEventMutex.RUnlock()
	return len(fake.setEventArgsForCall)
}

func (fake *TransactionContext) SetEventCalls(stub func(string, []byte) error) {
	fake.setEventMutex.Lock()
	defer fake.setEventMutex.Unlock()
	fake.SetEventStub = stub
}

func (fake *TransactionContext) SetEventArgsForCall(i int) (string, []byte) {
	fake.setEventMutex.RLock()
	defer fake.setEventMutex.RUnlock()
	argsForCall := fake.setEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *TransactionContext) SetEventReturns(result1 error) {
	fake.setEventMutex.Lock()
	defer fake.setEventMutex.Unlock()
	fake.SetEventStub = nil
	fake.setEventReturns = struct {
		result1 error
	}{result1}
}

func (fake *TransactionContext) SetEventReturnsOnCall(i int, result1 error) {
	fake.setEventMutex.Lock()
	defer fake.setEventMutex.Unlock()
	fake.SetEventStub = nil
	if fake.setEventReturnsOnCall == nil {
		fake.setEventReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setEventReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TransactionContext) SplitCompositeKey(arg1 string) (string, []string, error) {
	fake.splitCompositeKeyMutex.Lock()
	ret, specificReturn := fake.splitCompositeKeyReturnsOnCall[len(fake.splitCompositeKeyArgsForCall)]
	fake.splitCompositeKeyArgsForCall = append(fake.splitCompositeKeyArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SplitCompositeKeyStub
	fakeReturns := fake.splitCompositeKeyReturns
	fake.recordInvocation("SplitCompositeKey", []interface{}{arg1})
	fake.splitCompositeKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *TransactionContext) SplitCompositeKeyCallCount() int {
	fake.splitCompositeKeyMutex.RLock()
	defer fake.splitCompositeKeyMutex.RUnlock()
	return len(fake.splitCompositeKeyArgsForCall)
}

func (fake *TransactionContext) SplitCompositeKeyCalls(stub func(string) (string, []string, error)) {
	fake.splitCompositeKeyMutex.Lock()
	defer fake.splitCompositeKeyMutex.Unlock()
	fake.SplitCompositeKeyStub = stub
}

func (fake *TransactionContext) SplitCompositeKeyArgsForCall(i int) string {
	fake.splitCompositeKeyMutex.RLock()
	defer fake.splitCompositeKeyMutex.RUnlock()
	argsForCall := fake.splitCompositeKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *TransactionContext) SplitCompositeKeyReturns(result1 string, result2 []string, result3 error) {
	fake.splitCompositeKeyMutex.Lock()
	defer fake.splitCompositeKeyMutex.Unlock()
	fake.SplitCompositeKeyStub = nil
	fake.splitCompositeKeyReturns = struct {
		result1 string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *TransactionContext) SplitCompositeKeyReturnsOnCall(i int, result1 string, result2 []string, result3 error) {
	fake.splitCompositeKeyMutex.Lock()
	defer fake.splitCompositeKeyMutex.Unlock()
	fake.SplitCompositeKeyStub = nil
	if fake.splitCompositeKeyReturnsOnCall == nil {
		fake.splitCompositeKeyReturnsOnCall = make(map[int]struct {
			result1 string
			result2 []string
			result3 error
		})
	}
	fake.splitCompositeKeyReturnsOnCall[i] = struct {
		result1 string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *TransactionContext) ValidateCreateTokenTransaction(arg1 string, arg2 string, arg3 []string) error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.validateCreateTokenTransactionMutex.Lock()
	ret, specificReturn := fake.validateCreateTokenTransactionReturnsOnCall[len(fake.validateCreateTokenTransactionArgsForCall)]
	fake.validateCreateTokenTransactionArgsForCall = append(fake.validateCreateTokenTransactionArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3Copy})
	stub := fake.ValidateCreateTokenTransactionStub
	fakeReturns := fake.validateCreateTokenTransactionReturns
	fake.recordInvocation("ValidateCreateTokenTransaction", []interface{}{arg1, arg2, arg3Copy})
	fake.validateCreateTokenTransactionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *TransactionContext) ValidateCreateTokenTransactionCallCount() int {
	fake.validateCreateTokenTransactionMutex.RLock()
	defer fake.validateCreateTokenTransactionMutex.RUnlock()
	return len(fake.validateCreateTokenTransactionArgsForCall)
}

func (fake *TransactionContext) ValidateCreateTokenTransactionCalls(stub func(string, string, []string) error) {
	fake.validateCreateTokenTransactionMutex.Lock()
	defer fake.validateCreateTokenTransactionMutex.Unlock()
	fake.ValidateCreateTokenTransactionStub = stub
}

func (fake *TransactionContext) ValidateCreateTokenTransactionArgsForCall(i int) (string, string, []string) {
	fake.validateCreateTokenTransactionMutex.RLock()
	defer fake.validateCreateTokenTransactionMutex.RUnlock()
	argsForCall := fake.validateCreateTokenTransactionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *TransactionContext) ValidateCreateTokenTransactionReturns(result1 error) {
	fake.validateCreateTokenTransactionMutex.Lock()
	defer fake.validateCreateTokenTransactionMutex.Unlock()
	fake.ValidateCreateTokenTransactionStub = nil
	fake.validateCreateTokenTransactionReturns = struct {
		result1 error
	}{result1}
}

func (fake *TransactionContext) ValidateCreateTokenTransactionReturnsOnCall(i int, result1 error) {
	fake.validateCreateTokenTransactionMutex.Lock()
	defer fake.validateCreateTokenTransactionMutex.Unlock()
	fake.ValidateCreateTokenTransactionStub = nil
	if fake.validateCreateTokenTransactionReturnsOnCall == nil {
		fake.validateCreateTokenTransactionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateCreateTokenTransactionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *TransactionContext) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createCompositeKeyMutex.RLock()
	defer fake.createCompositeKeyMutex.RUnlock()
	fake.delStateWithKYCMutex.RLock()
	defer fake.delStateWithKYCMutex.RUnlock()
	fake.delStateWithoutKYCMutex.RLock()
	defer fake.delStateWithoutKYCMutex.RUnlock()
	fake.getChannelIDMutex.RLock()
	defer fake.getChannelIDMutex.RUnlock()
	fake.getClientIdentityMutex.RLock()
	defer fake.getClientIdentityMutex.RUnlock()
	fake.getFunctionAndParametersMutex.RLock()
	defer fake.getFunctionAndParametersMutex.RUnlock()
	fake.getHistoryForKeyMutex.RLock()
	defer fake.getHistoryForKeyMutex.RUnlock()
	fake.getKYCMutex.RLock()
	defer fake.getKYCMutex.RUnlock()
	fake.getQueryResultMutex.RLock()
	defer fake.getQueryResultMutex.RUnlock()
	fake.getSignedProposalMutex.RLock()
	defer fake.getSignedProposalMutex.RUnlock()
	fake.getStateMutex.RLock()
	defer fake.getStateMutex.RUnlock()
	fake.getStateByPartialCompositeKeyMutex.RLock()
	defer fake.getStateByPartialCompositeKeyMutex.RUnlock()
	fake.getStateByRangeMutex.RLock()
	defer fake.getStateByRangeMutex.RUnlock()
	fake.getTxIDMutex.RLock()
	defer fake.getTxIDMutex.RUnlock()
	fake.getTxTimestampMutex.RLock()
	defer fake.getTxTimestampMutex.RUnlock()
	fake.getUserIDMutex.RLock()
	defer fake.getUserIDMutex.RUnlock()
	fake.invokeChaincodeMutex.RLock()
	defer fake.invokeChaincodeMutex.RUnlock()
	fake.putKYCMutex.RLock()
	defer fake.putKYCMutex.RUnlock()
	fake.putStateWithKYCMutex.RLock()
	defer fake.putStateWithKYCMutex.RUnlock()
	fake.putStateWithoutKYCMutex.RLock()
	defer fake.putStateWithoutKYCMutex.RUnlock()
	fake.setEventMutex.RLock()
	defer fake.setEventMutex.RUnlock()
	fake.splitCompositeKeyMutex.RLock()
	defer fake.splitCompositeKeyMutex.RUnlock()
	fake.validateCreateTokenTransactionMutex.RLock()
	defer fake.validateCreateTokenTransactionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *TransactionContext) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
